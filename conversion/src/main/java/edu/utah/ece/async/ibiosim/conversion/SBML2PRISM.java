/*******************************************************************************
 *  
 * This file is part of iBioSim. Please visit <http://www.async.ece.utah.edu/ibiosim>
 * for the latest version of iBioSim.
 *
 * Copyright (C) 2017 University of Utah
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the Apache License. A copy of the license agreement is provided
 * in the file named "LICENSE.txt" included with this software distribution
 * and also available online at <http://www.async.ece.utah.edu/ibiosim/License>.
 *  
 *******************************************************************************/
package edu.utah.ece.async.ibiosim.conversion;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import javax.xml.stream.XMLStreamException;

import org.sbml.jsbml.Compartment;
import org.sbml.jsbml.Model;
import org.sbml.jsbml.ModifierSpeciesReference;
import org.sbml.jsbml.Parameter;
import org.sbml.jsbml.Reaction;
import org.sbml.jsbml.SBMLDocument;
import org.sbml.jsbml.SBMLReader;
import org.sbml.jsbml.Species;
import org.sbml.jsbml.SpeciesReference;
import org.sbml.jsbml.ext.comp.CompModelPlugin;
import org.sbml.jsbml.ext.comp.CompSBMLDocumentPlugin;
import org.sbml.jsbml.ext.comp.CompSBasePlugin;
import org.sbml.jsbml.ext.comp.ExternalModelDefinition;
import org.sbml.jsbml.ext.comp.ReplacedBy;
import org.sbml.jsbml.ext.comp.ReplacedElement;
import org.sbolstandard.core2.AccessType;
import org.sbolstandard.core2.ComponentDefinition;
import org.sbolstandard.core2.DirectionType;
import org.sbolstandard.core2.EDAMOntology;
import org.sbolstandard.core2.FunctionalComponent;
import org.sbolstandard.core2.Interaction;
import org.sbolstandard.core2.Module;
import org.sbolstandard.core2.ModuleDefinition;
import org.sbolstandard.core2.RefinementType;
import org.sbolstandard.core2.SBOLConversionException;
import org.sbolstandard.core2.SBOLDocument;
import org.sbolstandard.core2.SBOLReader;
import org.sbolstandard.core2.SBOLValidationException;
import org.sbolstandard.core2.Sequence;
import org.sbolstandard.core2.SequenceOntology;
import org.sbolstandard.core2.SystemsBiologyOntology;
import org.sbolstandard.core2.TopLevel;

import edu.utah.ece.async.ibiosim.dataModels.biomodel.annotation.AnnotationUtility;
import edu.utah.ece.async.ibiosim.dataModels.biomodel.parser.BioModel;
import edu.utah.ece.async.ibiosim.dataModels.biomodel.util.SBMLutilities;
import edu.utah.ece.async.ibiosim.dataModels.util.GlobalConstants;

/**
 * Perform conversion from SBML to PRISM. 
 *
 * @author Lukas Buecherl
 * @author Chris Myers
 * @author <a href="http://www.async.ece.utah.edu/ibiosim#Credits"> iBioSim Contributors </a>
 * @version %I%
 */
public class SBML2PRISM {
	
	/*
	 * Convert SBML to Prism
	 * Input: SBMLDocument, File
	 * Output: void
	 * 
	 * Function takes in a SBML document and writes the prism conversion of the file in the same directory. The function also translates the constraint into 
	 * a properties file that is written in the same directory in a separate file. The original filename is used for the prism and property file. The SBMML
	 * file ends in .xml, the prism file in .sm, and the properties file in .props.
	 * 
	 * To run the converter use the following command:
	 * java -jar conversion/target/iBioSim-conversion-3.1.0-SNAPSHOT-jar-with-dependencies.jar -l PRISM YOURSBMLFILE.xml
	 */
	public static void convertSBML2PRISM(SBMLDocument sbmlDoc, String filename) throws IOException 
	{
		Model model = sbmlDoc.getModel();
		File file = new File(filename.replace(".xml", ".sm"));
		
			// Opening and writing preamble to the file
			FileWriter out = new FileWriter(file);
			out.write("// File generated by SBML-to-PRISM converter\n");
			out.write("// Original file: " + filename + "\n");
			out.write("// @GeneticLogicLab\n");
			out.write("\n");
			out.write("ctmc\n");
			out.write("\n");
			
			
			out.write("// const int MAX_AMOUNT = ADD VALUE \n");
			out.write("\n");
			
			// Identify compartments and their size
			out.write("// Compartment size\n");
			
			for (int i = 0; i < model.getCompartmentCount(); i++) 
			{
				Compartment compartment = model.getCompartment(i);
				out.write("const double " + checkReservedKeywordPrism(compartment.getId()) + " = " + compartment.getSize() + ";\n");
				
			}
			
			out.write("\n");
			
			
			// Identify model parameters
			out.write("// Model parameters\n");
			
			for (int i = 0; i < model.getParameterCount(); i++) 
			{
				Parameter parameter = model.getParameter(i);
				out.write("const double "+ checkReservedKeywordPrism(parameter.getId()) + " = " + parameter.getValue() +"; // " +  parameter.getName() + "\n"); // if not null name
				
			}
			
			out.write("\n");
			
			// Identify model species
			for (int i = 0; i < model.getSpeciesCount(); i++) 
			{
				Species species = model.getSpecies(i);
				out.write("// Species " + checkReservedKeywordPrism(species.getId()) + "\n");
				out.write("// const int " + checkReservedKeywordPrism(species.getId()) + "_MAX = MAX_AMOUNT;\n");
				out.write("module "+ checkReservedKeywordPrism(species.getId()) + "\n");
				out.write("\n");
				out.write("  // "+ checkReservedKeywordPrism(species.getId()) +" : " + "[0.." + checkReservedKeywordPrism(species.getId()) + "_MAX] init "+ (int) species.getInitialAmount() + ";\n");
				out.write("  "+ checkReservedKeywordPrism(species.getId()) + "  :  " + "int init " + (int) (species.getInitialAmount()) + ";\n");
				out.write("\n");
				
				for (int j = 0; j < model.getReactionCount(); j++) 
				{
					Reaction reaction = model.getReaction(j);
					
					SpeciesReference reactant = reaction.getReactantForSpecies(species.getId());
					SpeciesReference product = reaction.getProductForSpecies(species.getId());
					
					if(reactant != null) 
					{ 
						out.write("		// " + checkReservedKeywordPrism(reaction.getId()) + "\n");
						out.write("		[" + checkReservedKeywordPrism(reaction.getId()) + "] " + checkReservedKeywordPrism(species.getId()) + " > " + (int) (reactant.getStoichiometry() - 1) + " -> (" + checkReservedKeywordPrism(species.getId()) + "\'=" + checkReservedKeywordPrism(species.getId()) + "-" + (int) reactant.getStoichiometry() + ");\n");
					} else if (product != null) 
					{
						out.write("		// " + checkReservedKeywordPrism(reaction.getId()) + "\n");
						out.write("		[" + checkReservedKeywordPrism(reaction.getId()) + "] " + checkReservedKeywordPrism(species.getId()) + " >= " + "0 -> (" + checkReservedKeywordPrism(species.getId()) + "\'=" + checkReservedKeywordPrism(species.getId()) + "+" + (int) product.getStoichiometry() + ");\n");
					}
					
				}			
				
				out.write("\n");
				out.write("endmodule\n");
				out.write("\n");

			}
			
			// Identify reaction rates
			
			out.write("// Reaction rates\n");
			out.write("module reaction_rates\n");
			out.write("\n");
			
			for (int i = 0; i < model.getReactionCount(); i++) 
			{
				Reaction reaction = model.getReaction(i);
				out.write("		// " + checkReservedKeywordPrism(reaction.getId()) + ":  ->  ");
				for(int j = 0; j < reaction.getProductCount(); j++)
				{
					out.write(checkReservedKeywordPrism(reaction.getProduct(j).getSpecies()) + " ");
				}
				out.write("\n");
				
				out.write("		[" + checkReservedKeywordPrism(reaction.getId()) + "]  " + checkReserveKeywordMath(SBMLutilities.convertMath2PrismProperty(reaction.getKineticLaw().getMath()), model) + " > 0 -> " + "(" +  checkReserveKeywordMath(SBMLutilities.convertMath2PrismProperty(reaction.getKineticLaw().getMath()), model) + ") : true;\n");
				out.write("\n");

			}
			out.write("endmodule\n");
			
			out.write("\n");
			out.write("// Reward structures (one per species)");
			out.write("\n");

			
			// Identify rewards
			for (int i = 0; i < model.getSpeciesCount(); i++) 
			{
				Species species = model.getSpecies(i);
				
				out.write("// Reward " + (i+1) + ": " + checkReservedKeywordPrism(species.getId()) + "\n");
				out.write("rewards " + "\"" + checkReservedKeywordPrism(species.getId()) + "\" true : " + checkReservedKeywordPrism(species.getId()) + "; endrewards\n");
			
			}

			out.close();
			
			// Write Properties File
			File property = new File(filename.replace(".xml", ".props"));
			FileWriter property_out = new FileWriter(property);
			
			property_out.write("// File generated by SBML-to-PRISM converter\n");
			property_out.write("// Original file: " + filename + "\n");
			property_out.write("// @GeneticLogicLab\n");
			property_out.write("\n");
			
			for (int i = 0; i < model.getConstraintCount(); i++) 
			{
				System.err.println(checkReserveKeywordMath(SBMLutilities.convertMath2PrismProperty(model.getConstraint(i).getMath()), model));
				property_out.write(checkReserveKeywordMath(SBMLutilities.convertMath2PrismProperty(model.getConstraint(i).getMath()), model));
			}
			
			property_out.close();
			
	}
		
		
		
	private static String checkReservedKeywordPrism(String speciesname)	
	{
		
		List<String> keywords = Arrays.asList("A", "bool", "clock", "const", "ctmc", "C", "double", "dtmc", "E", "endinit", "endinvariant", "endmodule",
				"endobservables", "endrewards", "endsystem", "false", "formula", "filter", "func", "F", "global", "G", "init", "invariant", "I", "int", "label", 
				"max", "mdp", "min", "module", "X", "nondeterministic", "observable", "observables", "of", "Pmax", "Pmin", "P", "pomdp", "popta", "probabilistic",
				"prob", "pta", "rate", "rewards", "Rmax", "Rmin", "R", "S", "stochastic", "system", "true", "U", "W");
		
		if (keywords.contains(speciesname))
		{
			return "_" + speciesname;
		}else {
			return speciesname;
		}
	}
		
	private static String checkReserveKeywordMath(String math, Model model) {
		
		List<String> keywords = Arrays.asList("A", "bool", "clock", "const", "ctmc", "C", "double", "dtmc", "E", "endinit", "endinvariant", "endmodule",
				"endobservables", "endrewards", "endsystem", "false", "formula", "filter", "func", "F", "global", "G", "init", "invariant", "I", "int", "label", 
				"max", "mdp", "min", "module", "X", "nondeterministic", "observable", "observables", "of", "Pmax", "Pmin", "P", "pomdp", "popta", "probabilistic",
				"prob", "pta", "rate", "rewards", "Rmax", "Rmin", "R", "S", "stochastic", "system", "true", "U", "W");
	
		ArrayList<String> speciesString = new ArrayList<String>();
		
		for (int i = 0; i < model.getSpeciesCount(); i++) 
		{
			Species species = model.getSpecies(i);
			
			if(keywords.contains(species.getId()))
			{
				speciesString.add(species.getId());
			}
			
		}
		
		//System.err.println(speciesString);
		
		for(int i = 0; i < keywords.size(); i++) 
		{
			if(speciesString.contains(keywords.get(i))) 
			{
				String Target = " " + keywords.get(i);
				//System.err.println(Target);
				math = math.replace(Target, "_" + keywords.get(i));
				//System.err.println(math);
				String TargetProperty = "(" + keywords.get(i);
				math = math.replace(TargetProperty, "(_" + keywords.get(i));
			}
		
		} 
		
		
		return math;
	}
	
}


