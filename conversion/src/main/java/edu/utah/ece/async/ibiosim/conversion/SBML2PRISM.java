/*******************************************************************************
 *  
 * This file is part of iBioSim. Please visit <http://www.async.ece.utah.edu/ibiosim>
 * for the latest version of iBioSim.
 *
 * Copyright (C) 2017 University of Utah
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the Apache License. A copy of the license agreement is provided
 * in the file named "LICENSE.txt" included with this software distribution
 * and also available online at <http://www.async.ece.utah.edu/ibiosim/License>.
 *  
 *******************************************************************************/
package edu.utah.ece.async.ibiosim.conversion;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


import org.sbml.jsbml.Compartment;
import org.sbml.jsbml.Model;
import org.sbml.jsbml.Parameter;
import org.sbml.jsbml.Reaction;
import org.sbml.jsbml.SBMLDocument;
import org.sbml.jsbml.Species;
import org.sbml.jsbml.SpeciesReference;

import edu.utah.ece.async.ibiosim.dataModels.biomodel.util.SBMLutilities;


/**
 * Perform conversion from SBML to PRISM.
 *
 * @author Lukas Buecherl
 * @author Chris Myers
 * @author <a href="http://www.async.ece.utah.edu/ibiosim#Credits"> iBioSim
 *         Contributors </a>
 * @version %I%
 */

public class SBML2PRISM {

	/*
	 * Convert SBML to Prism. Input: SBMLDocument, File, bound. Output: void
	 * 
	 * Function takes in a SBML document and writes the prism conversion of the file
	 * in the same directory. The function also translates the constraint into a
	 * properties file that is written in the same directory in a separate file. The
	 * original filename is used for the prism and property file. The SBMML file
	 * ends in .xml, the prism file in .sm, and the properties file in .props.
	 * 
	 * To run the converter use the following command: java -jar
	 * conversion/target/iBioSim-conversion-3.1.0-SNAPSHOT-jar-with-dependencies.jar
	 * -l PRISM YOURSBMLFILE.xml
	 * 
	 * The function also allows the translation into a bound model by simply adding the flag 
	 * -bound
	 */

	public static void convertSBML2PRISM(SBMLDocument sbmlDoc, String filename, boolean unbound) throws IOException {
		Model model = sbmlDoc.getModel();
		File file = new File(filename.replace(".xml", ".sm"));

		// Opening and writing preamble to the file
		FileWriter out = new FileWriter(file);
		out.write("// File generated by SBML-to-PRISM converter\n");
		out.write("// Original file: " + filename + "\n");
		out.write("// @GeneticLogicLab\n");
		out.write("\n");
		out.write("ctmc\n");
		out.write("\n");
		
		// Set bound limit if bound model is selected
		if (unbound) {
			out.write("// const int MAX_AMOUNT = ADD VALUE \n");
			out.write("\n");
		} else {
			double maxAmount = 0.0;
			for (int i = 0; i < model.getSpeciesCount(); i++) {
				Species species = model.getSpecies(i);
				if (species.getInitialAmount() > maxAmount) {
					maxAmount = species.getInitialAmount();
				}
			}
			out.write(" const int MAX_AMOUNT = " + (int) maxAmount + ";\n");
			out.write("\n");				out.write("\n");
		}

		
		// Identify compartments and their size
		out.write("// Compartment size\n");

		for (int i = 0; i < model.getCompartmentCount(); i++) {
			Compartment compartment = model.getCompartment(i);
			out.write("const double " + checkReservedKeywordPrism(compartment.getId()) + " = " + compartment.getSize()
					+ ";\n");
		}

		out.write("\n");

		// Identify model parameters
		out.write("// Model parameters\n");

		for (int i = 0; i < model.getParameterCount(); i++) {
			Parameter parameter = model.getParameter(i);
			out.write("const double " + checkReservedKeywordPrism(parameter.getId()) + " = " + parameter.getValue()
					+ "; // " + parameter.getName() + "\n"); // if not null name

		}

		out.write("\n");

		// Identify model species
		for (int i = 0; i < model.getSpeciesCount(); i++) {
			// Write out syntax
			// For function checkReservedKeywordPrism see below
			Species species = model.getSpecies(i);
			out.write("// Species " + checkReservedKeywordPrism(species.getId()) + "\n");
			
			if (unbound) {
				out.write("// const int " + checkReservedKeywordPrism(species.getId()) + "_MAX = MAX_AMOUNT;\n");
				out.write("module " + checkReservedKeywordPrism(species.getId()) + "\n");
				out.write("\n");
				out.write("  // " + checkReservedKeywordPrism(species.getId()) + " : " + "[0.."
						+ checkReservedKeywordPrism(species.getId()) + "_MAX] init " + (int) species.getInitialAmount()
						+ ";\n");
				out.write("  " + checkReservedKeywordPrism(species.getId()) + "  :  " + "int init "
						+ (int) (species.getInitialAmount()) + ";\n");
				out.write("\n");
			} else {
				out.write("const int " + checkReservedKeywordPrism(species.getId()) + "_MAX = MAX_AMOUNT;\n");
				out.write("module " + checkReservedKeywordPrism(species.getId()) + "\n");
				out.write("\n");
				out.write("  " + checkReservedKeywordPrism(species.getId()) + " : " + "[0.."
						+ checkReservedKeywordPrism(species.getId()) + "_MAX] init " + (int) species.getInitialAmount()
						+ ";\n");
				out.write("  // " + checkReservedKeywordPrism(species.getId()) + "  :  " + "int init "
						+ (int) (species.getInitialAmount()) + ";\n");
				out.write("\n");
			}

			// Iterate over reactions
			for (int j = 0; j < model.getReactionCount(); j++) {
				Reaction reaction = model.getReaction(j);

				// Identify reactants and products
				SpeciesReference reactant = reaction.getReactantForSpecies(species.getId());
				SpeciesReference product = reaction.getProductForSpecies(species.getId());

				if (reactant != null) {
					out.write("		// " + checkReservedKeywordPrism(reaction.getId()) + "\n");
					out.write("		[" + checkReservedKeywordPrism(reaction.getId()) + "] "
							+ checkReservedKeywordPrism(species.getId()) + " > "
							+ (int) (reactant.getStoichiometry() - 1) + " -> ("
							+ checkReservedKeywordPrism(species.getId()) + "\'="
							+ checkReservedKeywordPrism(species.getId()) + "-" + (int) reactant.getStoichiometry()
							+ ");\n");
				} else if (product != null) {
					
					if (unbound) {
						out.write("		// " + checkReservedKeywordPrism(reaction.getId()) + "\n");
						out.write("		[" + checkReservedKeywordPrism(reaction.getId()) + "] "
								+ checkReservedKeywordPrism(species.getId()) + " >= " + "0 -> ("
								+ checkReservedKeywordPrism(species.getId()) + "\'="
								+ checkReservedKeywordPrism(species.getId()) + "+" + (int) product.getStoichiometry()
								+ ");\n");
					} else {
						out.write("		// " + checkReservedKeywordPrism(reaction.getId()) + "\n");
						out.write("		[" + checkReservedKeywordPrism(reaction.getId()) + "] "
								+ checkReservedKeywordPrism(species.getId()) + " <= " + checkReservedKeywordPrism(species.getId()) + "_MAX-" 
								+ (int) product.getStoichiometry() + " -> ("
								+ checkReservedKeywordPrism(species.getId()) + "\'="
								+ checkReservedKeywordPrism(species.getId()) + "+" + (int) product.getStoichiometry()
								+ ");\n");
					}	
					
				}

			}

			out.write("\n");
			out.write("endmodule\n");
			out.write("\n");

		}

		// Identify reaction rate
		out.write("// Reaction rates\n");
		out.write("module reaction_rates\n");
		out.write("\n");

		for (int i = 0; i < model.getReactionCount(); i++) {
			Reaction reaction = model.getReaction(i);

			// Write state transitions
			out.write("		// " + checkReservedKeywordPrism(reaction.getId()) + ":  ->  ");
			for (int j = 0; j < reaction.getProductCount(); j++) {
				out.write(checkReservedKeywordPrism(reaction.getProduct(j).getSpecies()) + " ");
			}
			out.write("\n");

			// Get the math for the reaction rate
			out.write("		[" + checkReservedKeywordPrism(reaction.getId()) + "]  "
					+ checkReserveKeywordMath(
							SBMLutilities.convertMath2PrismProperty(reaction.getKineticLaw().getMath()), model)
					+ " > 0 -> " + "("
					+ checkReserveKeywordMath(
							SBMLutilities.convertMath2PrismProperty(reaction.getKineticLaw().getMath()), model)
					+ ") : true;\n");
			out.write("\n");

		}
		out.write("endmodule\n");

		out.write("\n");

		// Identify rewards
		out.write("// Reward structures (one per species)");
		out.write("\n");

		for (int i = 0; i < model.getSpeciesCount(); i++) {
			Species species = model.getSpecies(i);

			out.write("// Reward " + (i + 1) + ": " + checkReservedKeywordPrism(species.getId()) + "\n");
			out.write("rewards " + "\"" + checkReservedKeywordPrism(species.getId()) + "\" true : "
					+ checkReservedKeywordPrism(species.getId()) + "; endrewards\n");

		}

		out.close();

		writePRISMProperty(filename, model);

	}

	
	/*
	 * Writes PRISM property Input: (String) filename, (Model) model
	 * Output: void
	 * 
	 * Function checks the constraints of a SBML model and translates it 
	 * into the PRISM syntax. The properties are then written into a 
	 * .props file.
	 */
	private static void writePRISMProperty(String filename, Model model) throws IOException
	{
		// Write Properties File
		File property = new File(filename.replace(".xml", ".props"));
		FileWriter property_out = new FileWriter(property);

		// Property preamble
		property_out.write("// File generated by SBML-to-PRISM converter\n");
		property_out.write("// Original file: " + filename + "\n");
		property_out.write("// @GeneticLogicLab\n");
		property_out.write("\n");

		for (int i = 0; i < model.getConstraintCount(); i++) {
			// Get and write translation of constraint
			property_out.write(checkReserveKeywordMath(
					SBMLutilities.convertMath2PrismProperty(model.getConstraint(i).getMath()), model));
		}

		property_out.close();
	}

	/*
	 * Check for reserved keywords as species names Input: (String) NameOfSpecies
	 * Output: (String) _NameOfSpecies
	 * 
	 * Function checks if the name of a species is also a reserved keyword in the
	 * prism language. If that is the case, the species name is replaced by the
	 * species name lead by an underscore.
	 */
	private static String checkReservedKeywordPrism(String speciesname) {
		// List of reserved keywords in the prism language
		List<String> keywords = Arrays.asList("A", "bool", "clock", "const", "ctmc", "C", "double", "dtmc", "E",
				"endinit", "endinvariant", "endmodule", "endobservables", "endrewards", "endsystem", "false", "formula",
				"filter", "func", "F", "global", "G", "init", "invariant", "I", "int", "label", "max", "mdp", "min",
				"module", "X", "nondeterministic", "observable", "observables", "of", "Pmax", "Pmin", "P", "pomdp",
				"popta", "probabilistic", "prob", "pta", "rate", "rewards", "Rmax", "Rmin", "R", "S", "stochastic",
				"system", "true", "U", "W");

		// Check if species name is in the list
		if (keywords.contains(speciesname)) {
			return "_" + speciesname;
		} else {
			return speciesname;
		}
	}

	/*
	 * Check for reserved keywords as species names in math properties Input:
	 * (String) NameOfSpecies, model sbmlDoc.getModel(); Output: (String)
	 * _NameOfSpecies
	 * 
	 * Function checks if the name of a species in a math function is also a
	 * reserved keyword in the prism language. If that is the case, the species name
	 * in the function is replaced by the species name lead by an underscore.
	 */
	private static String checkReserveKeywordMath(String math, Model model) {

		// List of reserved keywords in the prism language
		List<String> keywords = Arrays.asList("A", "bool", "clock", "const", "ctmc", "C", "double", "dtmc", "E",
				"endinit", "endinvariant", "endmodule", "endobservables", "endrewards", "endsystem", "false", "formula",
				"filter", "func", "F", "global", "G", "init", "invariant", "I", "int", "label", "max", "mdp", "min",
				"module", "X", "nondeterministic", "observable", "observables", "of", "Pmax", "Pmin", "P", "pomdp",
				"popta", "probabilistic", "prob", "pta", "rate", "rewards", "Rmax", "Rmin", "R", "S", "stochastic",
				"system", "true", "U", "W");

		// Declaration of new string list
		ArrayList<String> speciesString = new ArrayList<String>();

		// Iterating over species, if species name is a reserved keyword add it to list
		// speciesString
		for (int i = 0; i < model.getSpeciesCount(); i++) {
			Species species = model.getSpecies(i);

			if (keywords.contains(species.getId())) {
				speciesString.add(species.getId());
			}

		}

		// System.err.println(speciesString);

		// Iterate over list and replace species name
		for (int i = 0; i < keywords.size(); i++) {
			if (speciesString.contains(keywords.get(i))) {
				// Replace species in math equations
				// In equations species names are lead by a space
				String Target = " " + keywords.get(i);
				// System.err.println(Target);
				math = math.replace(Target, "_" + keywords.get(i));
				// System.err.println(math);

				// Replace species names in property files
				// In property files species names are lead by a (
				String TargetProperty = "(" + keywords.get(i);
				math = math.replace(TargetProperty, "(_" + keywords.get(i));
			}

		}

		return math;
	}

}
